@using AdventOfCSharp.Puzzles.Geometery;
@using AdventOfCSharp.Puzzles.Parsing;
@using AdventOfCSharp.Puzzles.Year22.Day12;
@using System.Drawing;
@using Blazor.Extensions.Canvas.Canvas2D;
@using Blazor.Extensions;
@inject IJSRuntime JsRuntime;

<h2>HTML 5 Visualisation</h2>
<P> This is a standard requestAnimationFrame loop, with interop within the frame function to call the C# Web Assembly file. </P>
<BECanvas Width="900" Height="400" @ref="_canvasReference"></BECanvas>

<MudButton Variant="Variant.Filled" Color="MudBlazor.Color.Secondary" OnClick="ProcessSomething">Part One</MudButton>
<MudButton Variant="Variant.Filled" Color="MudBlazor.Color.Secondary">Part Two</MudButton>
<h3>Stats</h3>
Pixel Density Ratio: @_dpr

@code {
    private Canvas2DContext? _context;
    protected BECanvasComponent? _canvasReference;
    private float _dpr;
    private bool _runningPartOne;
    public float _partOneIncrement;
    private Dictionary<Point2D, char> _map;
    private float _lastTimeStamp;
    private bool _drawMap;
    private Queue<Point2D> _queue;
    private Dictionary<Point2D, int> _distances;
    int _fpsscale = 255;
    private Queue<Point2D> _prevQueue = new Queue<Point2D>();

    protected override async Task OnInitializedAsync()
    {
        await JsRuntime.InvokeAsync<object>("initGame", DotNetObjectReference.Create(this));

        _dpr = await JsRuntime.InvokeAsync<float>("getDisplayRatio", DotNetObjectReference.Create(this));

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _context = await _canvasReference.CreateCanvas2DAsync();

            await _context.SetFontAsync("10px courier");
            await _context.ScaleAsync(_dpr, _dpr);

            var puzzle = new Puzzle();
            _map = Puzzle.LoadData(puzzle.PuzzleInput());
            _map.OrderBy(x => x.Value);
        }
    }

    private Dictionary<char, string> _colors = new Dictionary<char, string>
    {
            { 'S', "#FF0000"},
            { 'E', "#00FF00"},
            { 'a', "#006600"},
            { 'b', "#00AA00"},
            { 'c', "#00DD00"},
            { 'd', "#2a4858"},
            { 'e', "#345060"},
            { 'f', "#3e5867"},
            { 'g', "#48616f"},
            { 'h', "#526977"},
            { 'i', "#5d727f"},
            { 'j', "#677b87"},
            { 'k', "#71838f"},
            { 'l', "#7b8c97"},
            { 'm', "#86959f"},
            { 'n', "#909fa8"},
            { 'o', "#9ba8b0"},
            { 'p', "#a6b1b9"},
            { 'q', "#b1bbc1"},
            { 'u', "#bbc4ca"},
            { 'v', "#c7ced3"},
            { 'r', "#d2d7db"},
            { 's', "#dde1e4"},
            { 't', "#e8ebed"},
            { 'w', "#f4f5f6"},
            { 'x', "#ffffff"},
            { 'y', "#ffffff"},
            { 'z', "#ffffff"},
    };

    private async ValueTask DrawCell(Point2D pos, char val, string color)
    {
        await _context.SetFillStyleAsync(color);
        await _context.FillTextAsync($"{val}", pos.X * 6, 30 + (pos.Y * 7));
    }

    private async ValueTask DrawMap()
    {
        await _context.ClearRectAsync(0, 0, _canvasReference.Width, _canvasReference.Height);

        foreach (var item in _map)
        {
            await DrawCell(item.Key, item.Value, _colors[item.Value]);
        }
    }

    public async Task ProcessSomething()
    {
        _runningPartOne = !_runningPartOne;

        if (_runningPartOne)
        {
            await _context.BeginBatchAsync();
            await DrawMap();
            await _context.EndBatchAsync();

            var start = Puzzle.GetStart(_map);

            _queue = new Queue<Point2D>();
            _queue.Enqueue(start);

            _distances = new Dictionary<Point2D, int>();
            _distances[start] = 0;
        }
    }

    private async ValueTask UpdateModel(float timeStamp)
    {
        if (_queue.Count == 0)
        {
            _runningPartOne = false;
            return;
        };

        Puzzle.RunQueue(_map, _distances, _queue);

        foreach (var item in _queue)
        {
            if (!_prevQueue.Contains(item))
            {
                await DrawCell(item, _map[item], "#00FFFF");    
            }
        }

        _prevQueue = new Queue<Point2D>();
        foreach (var item in _queue)
        {
            _prevQueue.Enqueue(item);
        }
    }

    private async ValueTask DrawHeader(float delta)
    {
        var fps = Convert.ToInt32(1000 / delta);
        await _context.ClearRectAsync(0, 0, 800, 20);
        await _context.SetStrokeStyleAsync($"RGB({_fpsscale} {_fpsscale} {_fpsscale})");
        await _context.StrokeTextAsync($"FPS: {fps}", 0, 10);
    }

    [JSInvokable]
    public async ValueTask GameLoop(float timeStamp)
    {
        await _context.BeginBatchAsync();
        var delta = timeStamp - _lastTimeStamp;
        _lastTimeStamp = timeStamp;

        if (_context == null || _map == null) return;

        if (!_drawMap)
        {
            await DrawMap();
            _drawMap = true;
        }

        await DrawHeader(delta);

        if (_runningPartOne)
        {
            _partOneIncrement += delta;
        }
        if (_partOneIncrement > 16)
        {
            for (int i = 0; i < 10; i++)
            {
                await UpdateModel(timeStamp);
            }   
            _partOneIncrement = 0;
        }
        await _context.EndBatchAsync();
    }
}
