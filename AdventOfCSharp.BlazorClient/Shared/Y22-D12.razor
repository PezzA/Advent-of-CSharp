@using AdventOfCSharp.Puzzles.Geometery;
@using AdventOfCSharp.Puzzles.Parsing;
@using AdventOfCSharp.Puzzles.Year22.Day12;
@using System.Drawing;
@using Blazor.Extensions.Canvas.Canvas2D;
@using Blazor.Extensions;
@inject IJSRuntime JsRuntime;

<h2>HTML 5 Visualisation</h2>
<p> This is a standard requestAnimationFrame loop, with interop within the frame function to call the C# Web Assembly file. </p>
<BECanvas Width="@_width" Height="@_height" @ref="_canvas"></BECanvas>

<h3>Controls</h3>
<MudButton Variant="Variant.Filled" Color="MudBlazor.Color.Secondary" OnClick="StartPartOne">Part One</MudButton>
<MudButton Variant="Variant.Filled" Color="MudBlazor.Color.Secondary">Part Two</MudButton>

<MudSlider @bind-Value="_checksPerFrame" Min="1" Max="80" Color="MudBlazor.Color.Info">Checks Per Update: @_checksPerFrame</MudSlider>
<MudSlider @bind-Value="_updateTimer" Min="1" Max="60" Color="MudBlazor.Color.Warning">Updates Per Second: @_updateTimer</MudSlider>

<h3>Info</h3>
devicePixelRatio : @_dpr

@code {
    // Canvas
    private Canvas2DContext? _context;
    protected BECanvasComponent? _canvas;
    private int _width = 900;
    private int _height = 400;
    private float _dpr = 0;
    private int _cellWidth = 0;
    private int _checksPerFrame = 5;
    private float _updateTimer = 60;

    // Puzzle
    private Dictionary<Point2D, char>? _map;
    private Queue<Point2D>? _queue;
    private List<Point2D>? _drawQueue;
    private Dictionary<Point2D, int>? _distances;
    private bool _finished;

    // View Logic
    private bool _runningPartOne;
    public float _partOneIncrement;
    private float _lastTimeStamp;
    private Queue<Point2D> _prevQueue = new Queue<Point2D>();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (_canvas == null) return;

            _dpr = await JsRuntime.InvokeAsync<float>("setupCanvas", _canvas, _width, _height);
            _context = await _canvas.CreateCanvas2DAsync();

            var dpr = _dpr == 0 ? 1 : _dpr;

            await _context.ScaleAsync(dpr, dpr);
            await _context.SetFontAsync("10px courier");


            var puzzle = new Puzzle();
            var lines = puzzle.PuzzleInput().ParseStringArray();

            _cellWidth = _width / lines[0].Length;

            _map = Puzzle.LoadData(puzzle.PuzzleInput());
            _map.OrderBy(x => x.Value);
            await _context.BeginBatchAsync();
            await UI.Y22D12.RenderMap(_colors, _map, _cellWidth, _context, _canvas);
            await _context.EndBatchAsync();
        }
    }

    private Dictionary<char, string> _colors = new Dictionary<char, string>
    {
        { 'S', "#FF0000"},
        { 'E', "#00FF00"},
        { 'a', "#006600"},
        { 'b', "#00AA00"},
        { 'c', "#00DD00"},
        { 'd', "#2a4858"},
        { 'e', "#345060"},
        { 'f', "#3e5867"},
        { 'g', "#48616f"},
        { 'h', "#526977"},
        { 'i', "#5d727f"},
        { 'j', "#677b87"},
        { 'k', "#71838f"},
        { 'l', "#7b8c97"},
        { 'm', "#86959f"},
        { 'n', "#909fa8"},
        { 'o', "#9ba8b0"},
        { 'p', "#a6b1b9"},
        { 'q', "#b1bbc1"},
        { 'u', "#bbc4ca"},
        { 'v', "#c7ced3"},
        { 'r', "#d2d7db"},
        { 's', "#dde1e4"},
        { 't', "#e8ebed"},
        { 'w', "#f4f5f6"},
        { 'x', "#ffffff"},
        { 'y', "#ffffff"},
        { 'z', "#ffffff"},
    };

    public async Task StartPartOne()
    {
        if (_canvas == null || _context == null || _map == null) return;

        await _context.BeginBatchAsync();
        await UI.Y22D12.RenderMap(_colors, _map, _cellWidth, _context, _canvas);
        await _context.EndBatchAsync();

        var start = Puzzle.GetStart(_map);

        _prevQueue = new Queue<Point2D>();

        _queue = new Queue<Point2D>();
        _queue.Enqueue(start);

        _distances = new Dictionary<Point2D, int>();
        _distances[start] = 0;
        _finished = false;
        _runningPartOne = true;

        await JsRuntime.InvokeAsync<object>("startAnimLoop", DotNetObjectReference.Create(this));
    }

    private void Update(float delta)
    {
        if (_canvas == null || _context == null || _map == null || _distances == null || _queue == null) return;

        if (!_runningPartOne) return;

        _partOneIncrement += delta;

        if (_partOneIncrement > (1000/_updateTimer))
        {
            _drawQueue = new List<Point2D>();

            for (int i = 0; i < _checksPerFrame; i++)
            {
                Puzzle.RunQueue(_map, _distances, _queue);

                foreach (var item in _queue)
                {
                    if (!_prevQueue.Contains(item))
                    {
                        _drawQueue.Add(item);
                    }
                }

                _prevQueue = new Queue<Point2D>();

                foreach (var item in _queue)
                {
                    _prevQueue.Enqueue(item);
                }

                if (_queue.Count == 0)
                {
                    _finished = true;
                    break;
                }

            }
            _partOneIncrement = 0;
        }
    }

    public async ValueTask Render(float delta, string drawState, Canvas2DContext context, BECanvasComponent canvas)
    {
        await context.BeginBatchAsync();

        await context.SetFillStyleAsync("#00FFFF");

        if (_drawQueue != null)
        {
            foreach (var item in _drawQueue)
            {
                await UI.Y22D12.DrawCell(item, string.Empty, _cellWidth, context);
            }

        }

        await UI.Y22D12.RenderHeader(delta, context, canvas);
        
        await context.EndBatchAsync();
    }

    [JSInvokable]
    public async ValueTask GameLoop(float timeStamp)
    {
        if (_context == null || _canvas == null || _map == null) return;

        var delta = timeStamp - _lastTimeStamp;
        _lastTimeStamp = timeStamp;

        Update(delta);

        await Render(delta, "", _context, _canvas);
    }
}
